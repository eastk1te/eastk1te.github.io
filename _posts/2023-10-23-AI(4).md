---
title: '[AIMA]Chapter 5, 대립 검색과 게임.'
author: east
date: 2023-10-23 00:00:00 +09:00
categories: [ML, AIMA]
tags: ['AI : A Modern Approach 4th']
math: true
mermaid: true
# pin: true
# image:
#    path: image preview url
#    alt: image preview text
---

해당 포스트는 공부를 위해 개인적으로 정리한 내용으로 해당 도서에는 다양한 예시를 통해 좀 더 직관적인 이해가 가능합니다.

작성시 목차에 의존하지 말고 내가 직접 생각하면서 정리하기!
만약 목차대로 작성한다면 그냥 "깜지"랑 다를게 없지 않은가?

Artificial Intelligence : A Modern Approach 4th Edition

## Chapter 5. 대립 검색과 게임

이번 장에서는 다른 에이전트들이 우리의 에이전트를 방해하려 하는 환경을 살펴본다.

둘 이상의 에이전트가 서로 상출하는 목표를 가지고 활동하는 경쟁적 환경$$_{competitive-enviroment}$$과 그런 환경에서 발생하는 대립 검색$$_{adversarial-search}$$ 문제들을 살펴본다.

## 1. 게임 이론

다중 에이전트 환경에 관한 접근방식은 적어도 세 가지이다.
1. 환경을 하나의 경제로 뭉뚱그려서 고찰하는 것
2. 우리의 에이전트와 대립하는 에이전트들을 그냥 환경의 일부로 간주하는 것
3. 대립 에이전트들을 대립 게임 트리 검색 기법들을 이용해서 명시적으로 모형화 하는 것

한정된 범주의 게임들로 시작해서 최적의 수$$_{move}$$를 정의하고, 그 수를 찾아내는 알고리즘인 최소최대 검색 알고리즘을 소개한다. 검색을 마치기로 한 각 상태에 대해, 그 상태에서 누가 이겼는지 판정하는 방법은 크게 두가지인데, 하나는 발견적 평가 함수$$_{evaluiation-function}$$로 상태의 특징들에 기초해서 승자를 추정하는 것이고, 다른 하나는 그 상태에서 끝까지 게임을 여러 번 빠르게 모의 실행하는 결과들의 ㅎ평균으로 승자를 정하는 것이다.

### 제로섬 게임

이론가들은 게임들을 결정론적⋅2인용⋅교대식$$_{turn-taking}$$⋅완전 정보⋅제로섬$$_{zero-sum; 영합}$$게임으로 분류한다. 2인용 게임의 두 플레이어를 MAX와 MIN이라고 부르는데, MAX가 먼저 수를 두고 번걸아가면서 수를 둔다.이런 게임은 일종의 검색 문제로 형식화가 가능한데, 종료 상태 s로 끝난 게임에서 플레이어 p의 최종 수치를 정의하는 Utility함수나 초기 상태와 ACTIONS함수, RESULT 함수는 상태 공간 그래프를 정의하고 이 그래프의 일부에 검색 트리를 겹쳐서 다음 수를 결정한다. 각각의 말단 상태에 도달하는 모든 경로를 갖춘 검색  트리를 완전 게임 트리 라고 부른다.

## 2. 게임의 최적 결정

MAX는 승리로 이어지는 동작열을 찾으려 하고, MIN은 그것을 방해하려 한다. 결과가 이분법적인 게임에서는 AND-OR검색으로 조건부 계획을 생성하면 될 것이다.그러나 셋 이상의 결과가 가능한 게임들에서는 최소최대 검색$$_{minmax-search}$$라는 더 일반적인 알고리즘이 필요하다.

주어진 게임 트리에 대한 최적 전략은 트리의 각 상태의 최소최대 가치를 구해서 결정할 수 있따. 한 상태의 최소최대 가치는 두 플레이어가 그 상태로부터 게임을 끝까지 최적으로 플레이한다고 가정하고 계싼한, 상태에서의 효용 가치이다.

MAX의 최적 플레이에 대한 이 정의는 MIN 역시 최적으로 플레이한다는, 즉 MAX에 대한 최악의 경우의 결과를 최대화하려 한다는 가정을 깔고 있다. 만일 MIN이 최적으로 플레이 하지 않으면 어떻게 될까? 최적이 아닌 상대에 대해 항상 최소최대 최적 수를 두는 것이 최선은 아니다. 둘다 최적으로 플레이한다면 무승부가 되겠지만, MAX는 확실한 무승부보다는 90% 확률의 승리가 더 낫다는 점에 근거해서 대담한 수를 시도할 것이다.

### 최소최대 알고리즘
MINMAX(s)를 구할 수 있다면, 그에 기초해서 MAX를 위한 최선의 수를 찾는 검색 알고리즘을 만들 수 있따. 이 알고리즘은 재귀적으로 트리의 말단 노드까지 나아가고, 재귀가 풀리면서 트리를 타고 최소최대 가치들을 되짚어 돌아온다. 게임 트리에 대해 완결적인 DFS를 수행하기에 시간 복잡도가 지수적이라 사실상 불가능하지만 해당 알고리즘은 게임의 수학적 분석을 위한 토대의 역할을 한다.

### 다인용 게임의 최적 결정

_Figure 1 : 5-1_

셋 이상의 플레이어가 참여하는 게임은 어떻게 될까? 확장은 기술적인 관점에서는 간단하지만, 개념적으로는 몇 가지 흥미로운 새 주제를 던져준다. 우선, 하나의 가치가 아닌 가치들의 벡터를 부여해야하는데 간단하게 UTILITY 함수가 효용 가치들의 벡터를 돌려주게 하는 것이다. 다음으로, 비말단 상태들을 고려해야한다.
그리고 2인용 게임에 비해 다인용 게임에서는 게임 상황이 훤ㄹ씬 복잡한데, 플레이어들 사이의 동맹이라는 요소가 흔히 개입한다. 이 경우 전적으로 이기적인 행동에 의해 협력이라는 현상이 창발한다.

### 알파베타 가지치기
최소최대 검색의 문제점은 조사해야 할 게임 상태의 수가 게임 트리 깊이에 지수적이라는 점이다. 지수를 완전히 제거할 수는 없지만, 실질적으로 반감하는 것은 가능하다. 

가지치기를 이용해 트리의 커다란 부분을 고려 대상으로 제외함으로써 모든 노드를 검색하지 않아도 최소최대 결정이 가능해진다.

알파베타 가지치기는 임의의 깊이의 트리에 적용할 수 있으며, 말단 노드뿐만 아니라 부분 트리를 통째로 잘라낼 수 있는 경우도 많다. 일반 원리는 특정 노드에 도달했는데 같은 수준이나 더 높은 수준에서 더 나은 수가 존재한다면 n을 쳐내도 된다. 이렇듯 최소최대 검색이 깊이 우선방식임을 기억하기 바란다. 

$\alpha=MAX$에 대한 경로에 있는 임의의 선택 지점에서 지금까지 발견한 가치가 가장 큰 선택의 가치 $\alpha$를 "최소 가치"로 생각할 수 있다.
$\beta=MIN$에 대한 경로에 있는 임의의 선택 지점에서 지금까지 발견한 가치가 가장 작은 선택의 가치 $\beta$를 "최대 가치"로 생각할 수 있다.

α와 β의 값을 갱신하고 MAX에 대해 현재 α 값보다 나쁜, MIN에 대해서는 현재 β 값보다 나쁜 가치를 가진 노드를 발견하면 그 노드의 나머지 가지들을 쳐낸다.

### 수들의 순서 결정

알파베다 가지치기의 효과는 상태들을 조사하는 순서에 크게 의존한다. 다른말로하면, 수들의 순서를 완벽하게 결정할 수 있는 경우 알파베타는 같은 시간 동안 트리를 약 두 배나 더 깊이 탐색할 수 있지만, 완벽하게 결정하는 것은 사실 불가능하다.

최선의 수들을 흔히 킬러 수$$_{killer-move}$$라고 부르고, 그런 수들을 먼저 고려하는 방식을 킬러 수 발견법이라고 부른다.

게임 트리 검색의 경우 반복된 상태들은 전치들, 즉 결국은 같은 국면이 되지만 수들의 순서가 다른 수순들 때문에 발생할 수 있으며, 이 문제는 상태들의 발견적 가치들을 담은 전치 테이블로 해결할 수 있따.

그러나 이러한 가지치기와 순서 결정 기법을 사용해도 상태가 너무 많은 게임에서는 통하지 않는다.
이러한 문제점을 지적하고 나온 두 개의 전략으로 
- A형 전략 : 검색 트리 의 일정 깊이까지 모든 수를 고려하고, 그런 다음 발견적 평가 함수를 이용해서 그 깊이에 있는 상태들의 효용을 추정, 넓지만 얕게
- B형 전략 : 나빠 보이는 수들을 무시하고, 유망한 수순들을 "최대한 멀리"따라가 본다. 이것은 트리를 깊지만 좁게 탐색하는 것

## 발견적 알파베타 트리 검색

제한된 계산 시간을 최대한 활용하는 방법 하나는 검색을 일찍 중단$$_{cut-off}$$하고 발견적 평가 함수를 상태들에 적용하는 것이다. 상태의 효용을 계싼 하는 UTILITY함수 대신 효용을 추정하는 EVAL함수를 사용한다. 또한 종료 판정 대신 중단 판정을 사용한다.

### 평가 함수
발견적 평가 함수 EVAL(s,p)는 상태s에서 플레이어 p에 대한 기대 효용의 추정치를 돌려준다. 말단 상태들에서는 반드시 UTILITY함수와 동치이고, 비말단 상태들에서는 승리와 패배 사이의 어딘가에 해당하는 추정치를 돌려주어야한다.

좋은 평가 함수의 요건은 무엇일까? 시간이 많이 걸리면 안되고, 실제 승리 가능성과 상관관계까 높은 추정치를 돌려주어야 한다.
여기서 '승리 가능성'이 구체적으로 무엇일까?  검색이 비말단 상태들에서 중단되어야 한다면, 알고리즘의 관점에서 그 상태들의 최종 결과는 불확실하다.대부분의 평가 함수는 상태의 다양한 특징들을 계싼에 포함시킨다. 그러한 특징들의 조합은 상태의 다양한 범주 또는 동치류$$_{equivalence-class}$$를 형성한다. 평가 함수는 어떤 상태가 어떤 결과로 이어지는지 알지 못하지만, 각 결과의 상태들이 차지하는 비율을 반영하는 하나의 값을 돌려줄 수는 있다.그러면 각 상태 범주마다 합당한 평가치인 기대 가치를 계싼할 수 있으며, 따라서그 어떤 상태에 대해서도 작동하는 평가 함수를 만들 수 있다.

대부분의 평가 함수는 특징별로 개별적인 수치 기여도를 계산한 후 그것들을 결합해서 전체 가치를 구한다. 그 예로 체스 말의 근사적인 기물 가치$$_{material-value}$$를 제시한다. 수학에서는 가중 선형 함수라고 부른다.

평가 함수가 승리 가능성과 강한 상관관계여야 한다고 말했는데 반드시 선형일 필요는 없고 각 특징의 기여가 다른 특징의 가치들과 독립적이라는 강력한 가정이 깔려있기에 비선형 결합도 사용한다.

### 검색 중단
검색을 중단하는 것이 적당한 지점에 도달했으면 발견적 EVAL 함수를 호출하도록 검색을 수정해야한다.

현재 각 재귀호출에서 깊이가 증가하도록 일부 관리$$_{bookkeeping}$$ 코드를 배치도 있다.
평가 함수는 소강$$_{quiescent}$$국면에서만, 향후 평가치들을 크게 변화시킬 유보 수$$_{pending-move}$$가 없는 국면에서만 적용해야한다. 이런 추가적인 소강 검색은 종종 국면의 불확실성을 빠르게 해소할 수 있는 특정 종류의 수들만 고려하는 제한된 형태로 실행된다. 지평선 효과$$_{horizon-effect;시계효과}$$는 제거하기가 좀 더 어렵다. 궁극적으로는 피할 수 없지만 지연 전술을 이용해서 일시적으로 피할 수는 있는 상대의 수를 만났을 때 발샌한다. 탈출 할 수 없는 길이 명확하지만 '지평선 너머'로 밀어내는 일련의 수들이 있따.이런 지평선 효과를 완화하는 한 가지 전략은 특이 연장$$_{singular-extension}$$을 허용하는 것이다. 주어진 국면에서 다른 모든 수보다 "확실히 더 나은"수를 '특이수'라고 부른다. 이 전략은 검색을 중단할 국면이라도 특이 수가 존재하면 검색을 더 연장함으로써 지평선 효과를 완화한다.

### 순방향 가지치기
알파베타 가지치기는 최종 평가에 영향을 미치지 않는 가지들을 쳐낸다. 순방향 가지치기는 나빠 보이지만 좋은 수일 수도 있는 수들을 제거한다. 이는 실수의 위험을 감수하고 계산 시간을 줄이는 전략이다.  한 가지 접근방식은 빔 검색이다. 이접근방식에서는 각 겹마다 모든 가능한 수를 고려하는 것이 아니라 한 '다발$$_{beam}$$'의 수들만, 좀 더 구체적으로는 평가 함수를 기준으로 최선의 수 n개만 고려한다.

probabilistic cut PROBCUT 알고리즘은 이전의 경험에서 얻은 통계치들을 이용해서 최선의 수들이 잘려 나갈 확률을 줄인다.
늦은 수 감소$$_{late-move-reduction}$$이라는 기법도 있는데, 수들의 순서가 잘 결정되었으며 가능한 수들의 목록에서 뒤를 있는 "늦은 수"들이 좋은 수들일 가능성이 좀 더 작다는 가정을 둔다.

### 검색 대 참조
여러 게임 플레이 프로그램ㅇ들이 개시와 끝내기에 검색 대신 테이블 참조를 사용하는 것도 수많은 기보들이 쌓여있어 좋은 방법이다. 흔히 보지 못한 국면이 나오면 그떄부터는 ㄹ프로그램이 테이블 참조 대신 검색을 사용해야 한다. 게임 종반 부근에서는 선택 가능한 수가 다시 적어지며 끝내기에 대한 컴퓨터의 분석은 사람이 할 수 있는 수준을 훨씬 상회한다. 컴퓨터는 하나의 정책을 산출해서 끝내기 분제를 완전히 풀 수 있다. 여기서 정책이란 모든 가능한 상태를 그 상태에서의 최선의 수로 사상하는 함수이다.

## 몬테카를로 트리 검색

발견적 알파베타 트리 검색을 바둑에 적용하면 중요한 약점 두가지가 드러난다.
첫쨰, 알파베타 검색은 분기가 많기에 겹$$_{ply}$$가 제한된다.
둘쨰, 좋은 평가 함수를 정의하기가 어렵다.
따라서 알파베타 트리 검색을 포기하고 몬테카를로 트리 검색$$_{Monte-Carlo-tree-search;MCTS}$$이라는 전략을 사용한다.

MCTC 전략은 발견적 평가 함수를 아예 사용하지 않는다. 대신 게임을 끝까지 모의로 진행하는 시뮤ㅜㄹ레이션을 여러 번 반복해서 구한 평균으로 그 상태의 효용 가치를 추정한다. 하나의 시뮬레이션$$_{playout}$$이나 롤아웃$$_{rollout}$$에서 알고리즘은 먼저 한 플레이어의 수를 선택하고 그 다음에 다른 플레이어의 수를 선택하는 과정을 반복하는 것이다. 

그런데 플레이아웃 도중 각 플레이어의 수는 어떻게 선택해야 할까?
플레이아웃에서 유용한 정보를 얻으려면 수들을 좋은 수들 쪽으로 편향시키는 플레이아웃 정책이 필요하다. 적당한 플레이아웃 정책을 마련했다고 할 때, 다음으로는 플레이아웃을 어떤 국면에서 시작할 것인가와 각 국면에 대해 플레이아웃을 몇 번이나 수행할 것인가이다. 간단하게 현재 상태에서 시작해서 시뮬레이션을 N회만큼 수행해서 승률이 제일 높은 수들을 찾는것이다. 이 접근방식은 순수 몬테카를로 검색에 해당한다.

대부분의 경우네는 이 정도로는 충분하지 않다. 계싼 자원을 선택적으로 집중하기 위해 선택 정책이 필요한데, 탐험이라는 요소와 활용이라는 요소의 균형을 맞추려한다. 탐험은 평가되지않은 상태들을 살펴보는 것을 말하고, 호라용은 이전 플레이아웃들에서 좋게 평가된 상태들의 가치를 좀 더 정확하게 추정하는 것을 말한다. 몬테카를로 트리 검색은 선택, 확장, 시뮬레이션, 역전파(피드백)와 같은 네 단계로 이루어진 과정을 반복하며 점차 키워나감으로써 탐험과 활용의 균형을 맞춘다.

전통적으로 몬테카를로 검색은 분기 계수가 아주 크거나 적절한 평가 함수를 정의하기 어려운 게임들에서 알파베타보다 낫다고 알려져있다. 알파베타의 핵심은 달성 가능한 평가 함수 점수가 가장 높은 노드로 이어지는 경로를 선택한다는 것이다. 반면 몬테카를로 검색은 여러 번의 플레이아웃에서 얻은 정보를 취합하므로, 한 번의 실수에 크게 영향을 받지 않는다.

두개를 결합하여 정해진 개수의 수들까지만 실행한 후 발견적 평가 함수를 적용하거나 무승부를 선언하는 이른 플레이아웃 종료 기법을 적용하면 될 것이다.

몬테카를로 검색은 하나의 묘수가 게임의 진행을 크게 바꿀 가능성이 있는 게임에서 약점을 보이고, 한쪽이 "명백하게" 이길 게임 상태를 바로 알아보지 못한다는 단점이 있다.

## 확률적 게임

확률적 게임은 무작위 요소를 도입함으로써 예측 불가능성을 좀 더 충실하게 반영한다. 우연 노드를 포함하여 게임트리를 구성하는데,이런 검색 문제를 풀려면 불확실한 상황에서 정확한 결정을 내리는 방법을 이해해야한다. 

우리가 할 수 있는 일은 국면의 기대 가치, 즉 우 연 노드들의 모든 가능한 결괏값의 평균을 계싼하는 것뿐이다. 결정론적 게임의 최소최대 가치를 우연노드가 있는 게임까지 포괄하도록 일반화한 기대최소최대 가치라는 개념에 도달하게 된다.

_Figure 2 : 5-2_


### 우연이 있는 게임을 위한 평가함수
기대최소최대를 근사하는 자명한 방법은 특정 지점에서 검색을 중단하고 각 말단 노드에 평가함수를 적용하는 것이다. 평가함수도 더 나은 국면에 더 높은 가치를 부여해야 마땅하다. '가치'의 의미를 좀 더 세심하게 다룰 필요가 있따. 일부 평가치를 바꾸면 선호 순서는 그대로라도 프로그램이 완전히 다르게 행동할 수 있는데 이러한 문제를 피하려면 평가 함수가 반드시 주어진 국면의 승리 확률에 대한 양의 선형 변환이어야한다는 점이 밝혀졌다.

알파베타의 장점은 최선의 플레이가 주어졌을 때 어차피 발생하지 않을 미래의 전개를 무시한다는 것이다. 즉, 알파베타는 발생할 가능성이 있는 사건들에 집중하지만 주사위 두 개를 굴린 후에 수를 두는게임에서는 발생할 가능성이 있는 수들의 순차열이라는 것이 존재하지 않는다. 따라서 우연이 있는 게임에서는 수를 아주 멀리 내다보는 것이 비현실적이다.

우연노드의 분기계수가 큰게임에서는 가능한 모든 우연 분기 중 일부만 순방향 가지치기를 이용해서 선택하는 기법이 바람직할 수 있따. 아니면 평가 함수에 의존하는 방법을 아예 포기하고 몬테카를로 트리 검색으로 전환할 수도있다.

## 부분 관측 가능 게임

"체스는 전쟁이다"라는 인용문이 있지만, 사실 체스에는 전쟁의 주된 특징인 부분 관측 가능성이 빠져있다.
### 크리그슈필: 부분 관측 가능 체스

체스에서 상대 플레이어 말들의 이동을 볼 수 없게끔 함. 수를 두는 과정에서 말을 잡은 경우, 킹이 체크 상태가 된 경우에만 공지됨.

믿음 상태 개념을 다시 떠올리면 믿음 상태는 지금까지의 지각들의 완전한 역사가 주어졌을 때 논리적으로 가능한 모든 체스판 상태의 집합에 해당한다. 게임이 진행됨에 따라 믿음 상태를 갱신하는 것은 다름 아닌 상태 추정 문제이다. 부분 관측 게임에서는 전략의 개념이 좀 다른데, 이 경우 받을 수 있는 모든 가능한 지각열에 대한 수를 지정해야한다.

크리그슈필에서의 승리 전략 또는 보장된 레크메이트는 각각의 가능한 지각열에 대해 현재 믿음 상태의 모든 가능한 체스판 상태에서 상대의 수와는 무관하게 실제로 체크메이트로 이어지는 전략이다. 이 정의에서 상대의 믿음 상태는 중요하지 않다.

이 외에도 확률적 체크메이트라는 믿음 상태의 모든 체스판 상태에 대해 작동하고 승리의 가능성이 확률적이다.

체크메이트 전략이 현재 믿음 상태의 체스판들 중 일부에 대해서만 작동하는 경우 우연적 체크메이트라고 부르는데, 주어진 전략이 실제로 승리할 확률이 얼마인가라는 질문으로 자연스럽게 이어지며  믿음 상태의 각 체스판이 실제 체스판일 확률이 얼마인가라는 질문으로 이어진다.

크리그슈필에서 각 플레이어의 목표는 기물들을 적절한 장소에 두는 것이 아니라, 상대가 자신의 기물의 위치를 파악하는 데 필요한 정보를 최소화하는 것이기 떄문이다. 예측 가능한 '최적'전략을 사용하면 상대에게 그러한 정보를 제공하게 된다. 따라서 부분 관측 가능 게임에서 최적의 플레이를 위해서는 다소 '무작위로'플레이할 의사가 있어야 한다. 그 예측 불가능성 떄문에 장기적으로는 강한 수(상대가 방비하지 않았을 가능성)가 된다.

그러한 전략을 계싼하기 위해서는 가능한 체스판 상태들의 확률을 알아야하는 딜레마는 게임 이론의 개념인 평형$$_{equilbbrium}$$해법을 도입해서 해소할 수 있다. 평형은 각 플레이어에 대해 최적의 무작위화된 전략을 지정하지만 여기서는 평형을 계산하는 비용이 너무 크다.






### 5.6.2 카드 게임

브리지, 휘스트, 하츠, 포커: **확률적 부분 관측 가능성**

- 카드의 무작위한 분배로 생긴 정보의 누락에서 기인

때문에 언뜻 주사위 게임과 비슷하나 게임 시작 상태를 모든 가능한 카드 분배에 해당하는 결과를 가진 하나의 **우연 노드**로 취급해서 **기대 가치**를 계산하여로 최선의 수를 선택하는 방법이 있다.

- 이렇게 되면 게임이 **완전 관측 가능** 게임이 된다. (**투시에 대한 평균**(?), averaging over clairvoyance)

하지만, 위 전략은 길을 잃을 가능성이 있다.

_Figure 5-3_

투시에 대한 평균 전략이 왜 실패하는지 이해할 것이다.





- 미래의 모든 상태가 자동으로 완벽한 지식을 갖춘 상태가 될 것이라 가정
    
    ⇒ 정보를 수집하는 동작들(모르는 정보를 캐는 과정)은 고려하지 않음
    
- 상대편에게 정보를 숨기거나 같은 편에게 정보를 제공하는 동작도 선택하지 않음
    - 포커에서 흔히 이야기하는 블러핑(bluffing)을 하지 않는다.
        - 어자피 상대가 다 알고 있다고 가정하니까!


이러한 방대한 분배 수를 다루는 한 가지 방법은 아래와 같다. 좀 더 구체적으로 말하면, 비슷한 손패들을 동일한 것으로 취급함으로써 분배의 수를 줄일 수 있다.

- 추상화(abstraction): 비슷한 손패들을 동일한 것으로 취급하여 분배의 수를 줄임
- 순방향 가지치기: N개만 무작위로 선택해서 기대가치 계산

## 5.7 게임 검색 알고리즘들의 한계

게임에서 최적의 결정을 계산하는 것은 대부분의 경우 처리 불가능한 문제이기 때문에, 모든 알고리즘에는 반드시 어떤 가정과 근사가 관여한다. 알파베타 검색은 평가 함수를 하나의 근사로 사용하고, 몬테카를로 검색은 무작위로 선택한 일단의 플레이아웃들에 대한 근사적인 평균을 계산한다. 

많은 알고리즘들이 위에서 언급됐지만 결국 알파베타와 몬테카를로 검색으로 나뉜다는 것을 알 수 있다.

두 알고리즘 각각의 근본적인 한계가 있다.

1. 알파베타 검색은 검색이 발견적 함수의 오차에 취약
2. 알파베타와 몬테카를로 검색은 적법한 수들의 가치를 계산한 후에야 최선의 수를 파악할 수 있는 것
    - 최선의 수가 명백한 상황에서도 계산 시간을 소비하는 것은 무의미
    - 메타추론(metareasoning): 추론에 관한 추론
3. 동일하게 추론이 개별 수(move) 수준에서 일어난다는 점
    - 사람이 플레이하는 방식(고수준의 목표, 상대의 퀸을 함정에 빠뜨리려는 의도)은 아니라는 점
    - 11장 계획 수립(planning)에 대해 논의하며 구체적인 표현들을 계획하는 방법 살펴볼 것임
4. 네번쨰 문제점은 기계학습을 검색과정에 도입하는 능력이다.
    - 19장


틱택토, MINMAX 알파베타 가지치기, 몬테카를로 구현.

> ## . REFERENCES

1. temp
2. temp
3. temp
4. temp


<br><br>
---